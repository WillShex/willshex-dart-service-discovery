# Example 6: Multi-Platform Provider (Flutter + Jaspr + Common)

This example demonstrates how to use the service discovery package in a multi-platform project with platform-specific implementations:
- **Common package**: Shared business logic (abstract `LoggingService` interface and `Provider`)
- **Flutter app**: Mobile/Desktop UI with `FileLoggingService`
- **Jaspr web app**: Web UI with `ConsoleLoggingService`

## Problem

When building multi-platform apps, you often want to:
1. Keep service interfaces in a common package
2. Use different implementations for different platforms (e.g., file logging on desktop, console logging on web)
3. Use different UI frameworks (Flutter vs Jaspr) for different platforms
4. Access services from common code without platform-specific dependencies

The challenge is that the `Provider` needs to be accessible from common code, but different platforms need to register different implementations.

## Solution

Use the `@Discovery` annotation in your common package to generate a platform-agnostic `Provider`, while each platform uses `@ConfigureDiscovery` to register its specific implementations.

### Project Structure

```
example6/
├── common/
│   ├── services/
│   │   └── logging_service.dart       # Abstract interface
│   └── provider.dart                   # @Discovery - generates Provider class
├── flutter_app/
│   ├── services/
│   │   └── file_logging_service.dart  # Flutter-specific implementation
│   └── main.dart                       # @ConfigureDiscovery with FileLoggingService
└── web_app/
    ├── services/
    │   └── console_logging_service.dart  # Web-specific implementation
    └── main.dart                          # @ConfigureDiscovery with ConsoleLoggingService
```

### Common Package

**common/services/logging_service.dart** (Abstract Interface):
```dart
abstract class LoggingService extends BasicService {
  void log(String message);
}
```

**common/provider.dart** (Platform-Agnostic Provider):
```dart
import "package:willshex_dart_service_discovery/willshex_dart_service_discovery.dart";
import "services/logging_service.dart";

part "provider.svc.dart";

// Provider class is generated by @Discovery
// No class declaration needed - generator creates complete class
```

### Platform-Specific Implementations

**Flutter App** (`flutter_app/services/file_logging_service.dart`):
```dart
class FileLoggingService extends LoggingService {
  @override
  void log(String message) {
    // Write to file (simplified for demo)
    print("[FILE LOG] $message");
  }
}
```

**Web App** (`web_app/services/console_logging_service.dart`):
```dart
class ConsoleLoggingService extends LoggingService {
  @override
  void log(String message) {
    // Use browser console
    print("[WEB LOG] $message");
  }
}
```

### Platform-Specific Registration

**flutter_app/main.dart:**
```dart
@ConfigureDiscovery(
  concrete: [FileLoggingService],  // Registers as LoggingService
)
void main() async {
  await Registrar.init();
  
  // Use provider from common package
  final logger = Provider.loggingService;
  logger.log("Hello from Flutter!");
}
```

**web_app/main.dart:**
```dart
@ConfigureDiscovery(
  concrete: [ConsoleLoggingService],  // Registers as LoggingService
)
void main() async {
  await Registrar.init();
  
  // Use provider from common package
  final logger = Provider.loggingService;
  logger.log("Hello from Jaspr!");
}
```

## Key Features

1. **Platform-agnostic Provider**: Lives in common code, accessible from anywhere
2. **Platform-specific implementations**: Each platform provides its own `LoggingService` implementation
3. **Concrete type registration**: Services register by their abstract interface (`LoggingService`), not concrete type
4. **No code duplication**: Interface and Provider are shared across platforms
5. **Type safety**: All service access is type-safe through the generated Provider

## Running the Example

```bash
# Generate code
cd examples/example6
dart run build_runner build --delete-conflicting-outputs

# Run Flutter app
dart flutter_app/main.dart

# Run Web app
dart web_app/main.dart
```

## Generated Code

The `@Discovery` annotation generates a utility class in `common/provider.svc.dart`:

```dart
class Provider {
  Provider._();
  
  static LoggingService get loggingService => 
      ServiceDiscovery.instance.resolve<LoggingService>();
}
```

Each platform's `@ConfigureDiscovery` generates a `Registrar` that registers the platform-specific implementation:

**Flutter:**
```dart
class Registrar {
  static Future<void> init() async {
    ServiceDiscovery.instance.register<LoggingService>(FileLoggingService());
    await ServiceDiscovery.instance.init();
  }
}
```

**Web:**
```dart
class Registrar {
  static Future<void> init() async {
    ServiceDiscovery.instance.register<LoggingService>(ConsoleLoggingService());
    await ServiceDiscovery.instance.init();
  }
}
```

## Benefits

- **Clean separation**: Common code doesn't know about platform-specific implementations
- **Easy testing**: Mock implementations can be injected for testing
- **Scalable**: Add new platforms by creating new implementations and registration
- **Type-safe**: Compile-time checking of service types
- **No boilerplate**: Provider and Registrar are fully generated
